/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef replication_TYPES_H
#define replication_TYPES_H

#include <dsn/cpp/serialization_helper/dsn.layer2_types.h>
#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace dsn { namespace replication {

struct partition_status {
  enum type {
    PS_INVALID = 0,
    PS_INACTIVE = 1,
    PS_ERROR = 2,
    PS_PRIMARY = 3,
    PS_SECONDARY = 4,
    PS_POTENTIAL_SECONDARY = 5
  };
};

extern const std::map<int, const char*> _partition_status_VALUES_TO_NAMES;

struct read_semantic {
  enum type {
    ReadInvalid = 0,
    ReadLastUpdate = 1,
    ReadOutdated = 2,
    ReadSnapshot = 3
  };
};

extern const std::map<int, const char*> _read_semantic_VALUES_TO_NAMES;

struct learn_type {
  enum type {
    LT_INVALID = 0,
    LT_CACHE = 1,
    LT_APP = 2,
    LT_LOG = 3
  };
};

extern const std::map<int, const char*> _learn_type_VALUES_TO_NAMES;

struct learner_status {
  enum type {
    LearningInvalid = 0,
    LearningWithoutPrepare = 1,
    LearningWithPrepareTransient = 2,
    LearningWithPrepare = 3,
    LearningSucceeded = 4,
    LearningFailed = 5
  };
};

extern const std::map<int, const char*> _learner_status_VALUES_TO_NAMES;

struct config_type {
  enum type {
    CT_INVALID = 0,
    CT_ASSIGN_PRIMARY = 1,
    CT_UPGRADE_TO_PRIMARY = 2,
    CT_ADD_SECONDARY = 3,
    CT_UPGRADE_TO_SECONDARY = 4,
    CT_DOWNGRADE_TO_SECONDARY = 5,
    CT_DOWNGRADE_TO_INACTIVE = 6,
    CT_REMOVE = 7,
    CT_ADD_SECONDARY_FOR_LB = 8,
    CT_PRIMARY_FORCE_UPDATE_BALLOT = 9
  };
};

extern const std::map<int, const char*> _config_type_VALUES_TO_NAMES;

struct node_status {
  enum type {
    NS_INVALID = 0,
    NS_ALIVE = 1,
    NS_UNALIVE = 2
  };
};

extern const std::map<int, const char*> _node_status_VALUES_TO_NAMES;

struct meta_ctrl_flags {
  enum type {
    ctrl_meta_freeze = 1,
    ctrl_disable_replica_migration = 2
  };
};

extern const std::map<int, const char*> _meta_ctrl_flags_VALUES_TO_NAMES;

struct meta_ctrl_type {
  enum type {
    meta_flags_invalid = 0,
    meta_flags_and = 1,
    meta_flags_or = 2,
    meta_flags_overwrite = 3
  };
};

extern const std::map<int, const char*> _meta_ctrl_type_VALUES_TO_NAMES;

class mutation_header;

class mutation_update;

class mutation_data;

class replica_configuration;

class prepare_msg;

class read_request_header;

class write_request_header;

class rw_response_header;

class prepare_ack;

class learn_state;

class learn_request;

class learn_response;

class group_check_request;

class group_check_response;

class node_info;

class meta_response_header;

class configuration_update_request;

class configuration_update_response;

class configuration_query_by_node_request;

class configuration_query_by_node_response;

class create_app_options;

class configuration_create_app_request;

class drop_app_options;

class configuration_drop_app_request;

class configuration_list_apps_request;

class configuration_list_nodes_request;

class configuration_cluster_info_request;

class configuration_create_app_response;

class configuration_meta_control_request;

class configuration_meta_control_response;

class configuration_proposal_action;

class configuration_balancer_request;

class configuration_balancer_response;

class configuration_drop_app_response;

class configuration_list_apps_response;

class configuration_list_nodes_response;

class configuration_cluster_info_response;

class query_replica_decree_request;

class query_replica_decree_response;

class replica_info;

class query_replica_info_request;

class query_replica_info_response;

class node_state;

typedef struct _mutation_header__isset {
  _mutation_header__isset() : pid(false), ballot(false), decree(false), log_offset(false), last_committed_decree(false) {}
  bool pid :1;
  bool ballot :1;
  bool decree :1;
  bool log_offset :1;
  bool last_committed_decree :1;
} _mutation_header__isset;

class mutation_header {
 public:

  mutation_header(const mutation_header&);
  mutation_header(mutation_header&&);
  mutation_header& operator=(const mutation_header&);
  mutation_header& operator=(mutation_header&&);
  mutation_header() : ballot(0), decree(0), log_offset(0), last_committed_decree(0) {
  }

  virtual ~mutation_header() throw();
   ::dsn::gpid pid;
  int64_t ballot;
  int64_t decree;
  int64_t log_offset;
  int64_t last_committed_decree;

  _mutation_header__isset __isset;

  void __set_pid(const  ::dsn::gpid& val);

  void __set_ballot(const int64_t val);

  void __set_decree(const int64_t val);

  void __set_log_offset(const int64_t val);

  void __set_last_committed_decree(const int64_t val);

  bool operator == (const mutation_header & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(decree == rhs.decree))
      return false;
    if (!(log_offset == rhs.log_offset))
      return false;
    if (!(last_committed_decree == rhs.last_committed_decree))
      return false;
    return true;
  }
  bool operator != (const mutation_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const mutation_header & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(mutation_header &a, mutation_header &b);

inline std::ostream& operator<<(std::ostream& out, const mutation_header& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _mutation_update__isset {
  _mutation_update__isset() : code(false), serialization_type(false), data(false) {}
  bool code :1;
  bool serialization_type :1;
  bool data :1;
} _mutation_update__isset;

class mutation_update {
 public:

  mutation_update(const mutation_update&);
  mutation_update(mutation_update&&);
  mutation_update& operator=(const mutation_update&);
  mutation_update& operator=(mutation_update&&);
  mutation_update() : serialization_type(0) {
  }

  virtual ~mutation_update() throw();
   ::dsn::task_code code;
  int32_t serialization_type;
   ::dsn::blob data;

  _mutation_update__isset __isset;

  void __set_code(const  ::dsn::task_code& val);

  void __set_serialization_type(const int32_t val);

  void __set_data(const  ::dsn::blob& val);

  bool operator == (const mutation_update & rhs) const
  {
    if (!(code == rhs.code))
      return false;
    if (!(serialization_type == rhs.serialization_type))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const mutation_update &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const mutation_update & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(mutation_update &a, mutation_update &b);

inline std::ostream& operator<<(std::ostream& out, const mutation_update& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _mutation_data__isset {
  _mutation_data__isset() : header(false), updates(false) {}
  bool header :1;
  bool updates :1;
} _mutation_data__isset;

class mutation_data {
 public:

  mutation_data(const mutation_data&);
  mutation_data(mutation_data&&);
  mutation_data& operator=(const mutation_data&);
  mutation_data& operator=(mutation_data&&);
  mutation_data() {
  }

  virtual ~mutation_data() throw();
  mutation_header header;
  std::vector<mutation_update>  updates;

  _mutation_data__isset __isset;

  void __set_header(const mutation_header& val);

  void __set_updates(const std::vector<mutation_update> & val);

  bool operator == (const mutation_data & rhs) const
  {
    if (!(header == rhs.header))
      return false;
    if (!(updates == rhs.updates))
      return false;
    return true;
  }
  bool operator != (const mutation_data &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const mutation_data & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(mutation_data &a, mutation_data &b);

inline std::ostream& operator<<(std::ostream& out, const mutation_data& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _replica_configuration__isset {
  _replica_configuration__isset() : pid(false), ballot(false), primary(false), status(true), learner_signature(false) {}
  bool pid :1;
  bool ballot :1;
  bool primary :1;
  bool status :1;
  bool learner_signature :1;
} _replica_configuration__isset;

class replica_configuration {
 public:

  replica_configuration(const replica_configuration&);
  replica_configuration(replica_configuration&&);
  replica_configuration& operator=(const replica_configuration&);
  replica_configuration& operator=(replica_configuration&&);
  replica_configuration() : ballot(0), status((partition_status::type)0), learner_signature(0) {
    status = (partition_status::type)0;

  }

  virtual ~replica_configuration() throw();
   ::dsn::gpid pid;
  int64_t ballot;
   ::dsn::rpc_address primary;
  partition_status::type status;
  int64_t learner_signature;

  _replica_configuration__isset __isset;

  void __set_pid(const  ::dsn::gpid& val);

  void __set_ballot(const int64_t val);

  void __set_primary(const  ::dsn::rpc_address& val);

  void __set_status(const partition_status::type val);

  void __set_learner_signature(const int64_t val);

  bool operator == (const replica_configuration & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(primary == rhs.primary))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(learner_signature == rhs.learner_signature))
      return false;
    return true;
  }
  bool operator != (const replica_configuration &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const replica_configuration & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(replica_configuration &a, replica_configuration &b);

inline std::ostream& operator<<(std::ostream& out, const replica_configuration& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _prepare_msg__isset {
  _prepare_msg__isset() : config(false), mu(false) {}
  bool config :1;
  bool mu :1;
} _prepare_msg__isset;

class prepare_msg {
 public:

  prepare_msg(const prepare_msg&);
  prepare_msg(prepare_msg&&);
  prepare_msg& operator=(const prepare_msg&);
  prepare_msg& operator=(prepare_msg&&);
  prepare_msg() {
  }

  virtual ~prepare_msg() throw();
  replica_configuration config;
  mutation_data mu;

  _prepare_msg__isset __isset;

  void __set_config(const replica_configuration& val);

  void __set_mu(const mutation_data& val);

  bool operator == (const prepare_msg & rhs) const
  {
    if (!(config == rhs.config))
      return false;
    if (!(mu == rhs.mu))
      return false;
    return true;
  }
  bool operator != (const prepare_msg &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const prepare_msg & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(prepare_msg &a, prepare_msg &b);

inline std::ostream& operator<<(std::ostream& out, const prepare_msg& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _read_request_header__isset {
  _read_request_header__isset() : pid(false), code(false), semantic(true), version_decree(true) {}
  bool pid :1;
  bool code :1;
  bool semantic :1;
  bool version_decree :1;
} _read_request_header__isset;

class read_request_header {
 public:

  read_request_header(const read_request_header&);
  read_request_header(read_request_header&&);
  read_request_header& operator=(const read_request_header&);
  read_request_header& operator=(read_request_header&&);
  read_request_header() : semantic((read_semantic::type)1), version_decree(-1LL) {
    semantic = (read_semantic::type)1;

  }

  virtual ~read_request_header() throw();
   ::dsn::gpid pid;
   ::dsn::task_code code;
  read_semantic::type semantic;
  int64_t version_decree;

  _read_request_header__isset __isset;

  void __set_pid(const  ::dsn::gpid& val);

  void __set_code(const  ::dsn::task_code& val);

  void __set_semantic(const read_semantic::type val);

  void __set_version_decree(const int64_t val);

  bool operator == (const read_request_header & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(code == rhs.code))
      return false;
    if (!(semantic == rhs.semantic))
      return false;
    if (!(version_decree == rhs.version_decree))
      return false;
    return true;
  }
  bool operator != (const read_request_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const read_request_header & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(read_request_header &a, read_request_header &b);

inline std::ostream& operator<<(std::ostream& out, const read_request_header& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _write_request_header__isset {
  _write_request_header__isset() : pid(false), code(false) {}
  bool pid :1;
  bool code :1;
} _write_request_header__isset;

class write_request_header {
 public:

  write_request_header(const write_request_header&);
  write_request_header(write_request_header&&);
  write_request_header& operator=(const write_request_header&);
  write_request_header& operator=(write_request_header&&);
  write_request_header() {
  }

  virtual ~write_request_header() throw();
   ::dsn::gpid pid;
   ::dsn::task_code code;

  _write_request_header__isset __isset;

  void __set_pid(const  ::dsn::gpid& val);

  void __set_code(const  ::dsn::task_code& val);

  bool operator == (const write_request_header & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(code == rhs.code))
      return false;
    return true;
  }
  bool operator != (const write_request_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const write_request_header & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(write_request_header &a, write_request_header &b);

inline std::ostream& operator<<(std::ostream& out, const write_request_header& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _rw_response_header__isset {
  _rw_response_header__isset() : err(false) {}
  bool err :1;
} _rw_response_header__isset;

class rw_response_header {
 public:

  rw_response_header(const rw_response_header&);
  rw_response_header(rw_response_header&&);
  rw_response_header& operator=(const rw_response_header&);
  rw_response_header& operator=(rw_response_header&&);
  rw_response_header() {
  }

  virtual ~rw_response_header() throw();
   ::dsn::error_code err;

  _rw_response_header__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  bool operator == (const rw_response_header & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const rw_response_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const rw_response_header & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(rw_response_header &a, rw_response_header &b);

inline std::ostream& operator<<(std::ostream& out, const rw_response_header& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _prepare_ack__isset {
  _prepare_ack__isset() : pid(false), err(false), ballot(false), decree(false), last_committed_decree_in_app(false), last_committed_decree_in_prepare_list(false) {}
  bool pid :1;
  bool err :1;
  bool ballot :1;
  bool decree :1;
  bool last_committed_decree_in_app :1;
  bool last_committed_decree_in_prepare_list :1;
} _prepare_ack__isset;

class prepare_ack {
 public:

  prepare_ack(const prepare_ack&);
  prepare_ack(prepare_ack&&);
  prepare_ack& operator=(const prepare_ack&);
  prepare_ack& operator=(prepare_ack&&);
  prepare_ack() : ballot(0), decree(0), last_committed_decree_in_app(0), last_committed_decree_in_prepare_list(0) {
  }

  virtual ~prepare_ack() throw();
   ::dsn::gpid pid;
   ::dsn::error_code err;
  int64_t ballot;
  int64_t decree;
  int64_t last_committed_decree_in_app;
  int64_t last_committed_decree_in_prepare_list;

  _prepare_ack__isset __isset;

  void __set_pid(const  ::dsn::gpid& val);

  void __set_err(const  ::dsn::error_code& val);

  void __set_ballot(const int64_t val);

  void __set_decree(const int64_t val);

  void __set_last_committed_decree_in_app(const int64_t val);

  void __set_last_committed_decree_in_prepare_list(const int64_t val);

  bool operator == (const prepare_ack & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(err == rhs.err))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(decree == rhs.decree))
      return false;
    if (!(last_committed_decree_in_app == rhs.last_committed_decree_in_app))
      return false;
    if (!(last_committed_decree_in_prepare_list == rhs.last_committed_decree_in_prepare_list))
      return false;
    return true;
  }
  bool operator != (const prepare_ack &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const prepare_ack & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(prepare_ack &a, prepare_ack &b);

inline std::ostream& operator<<(std::ostream& out, const prepare_ack& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _learn_state__isset {
  _learn_state__isset() : from_decree_excluded(false), to_decree_included(false), meta(false), files(false) {}
  bool from_decree_excluded :1;
  bool to_decree_included :1;
  bool meta :1;
  bool files :1;
} _learn_state__isset;

class learn_state {
 public:

  learn_state(const learn_state&);
  learn_state(learn_state&&);
  learn_state& operator=(const learn_state&);
  learn_state& operator=(learn_state&&);
  learn_state() : from_decree_excluded(0), to_decree_included(0) {
  }

  virtual ~learn_state() throw();
  int64_t from_decree_excluded;
  int64_t to_decree_included;
   ::dsn::blob meta;
  std::vector<std::string>  files;

  _learn_state__isset __isset;

  void __set_from_decree_excluded(const int64_t val);

  void __set_to_decree_included(const int64_t val);

  void __set_meta(const  ::dsn::blob& val);

  void __set_files(const std::vector<std::string> & val);

  bool operator == (const learn_state & rhs) const
  {
    if (!(from_decree_excluded == rhs.from_decree_excluded))
      return false;
    if (!(to_decree_included == rhs.to_decree_included))
      return false;
    if (!(meta == rhs.meta))
      return false;
    if (!(files == rhs.files))
      return false;
    return true;
  }
  bool operator != (const learn_state &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const learn_state & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(learn_state &a, learn_state &b);

inline std::ostream& operator<<(std::ostream& out, const learn_state& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _learn_request__isset {
  _learn_request__isset() : pid(false), learner(false), signature(false), last_committed_decree_in_app(false), last_committed_decree_in_prepare_list(false), app_specific_learn_request(false) {}
  bool pid :1;
  bool learner :1;
  bool signature :1;
  bool last_committed_decree_in_app :1;
  bool last_committed_decree_in_prepare_list :1;
  bool app_specific_learn_request :1;
} _learn_request__isset;

class learn_request {
 public:

  learn_request(const learn_request&);
  learn_request(learn_request&&);
  learn_request& operator=(const learn_request&);
  learn_request& operator=(learn_request&&);
  learn_request() : signature(0), last_committed_decree_in_app(0), last_committed_decree_in_prepare_list(0) {
  }

  virtual ~learn_request() throw();
   ::dsn::gpid pid;
   ::dsn::rpc_address learner;
  int64_t signature;
  int64_t last_committed_decree_in_app;
  int64_t last_committed_decree_in_prepare_list;
   ::dsn::blob app_specific_learn_request;

  _learn_request__isset __isset;

  void __set_pid(const  ::dsn::gpid& val);

  void __set_learner(const  ::dsn::rpc_address& val);

  void __set_signature(const int64_t val);

  void __set_last_committed_decree_in_app(const int64_t val);

  void __set_last_committed_decree_in_prepare_list(const int64_t val);

  void __set_app_specific_learn_request(const  ::dsn::blob& val);

  bool operator == (const learn_request & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(learner == rhs.learner))
      return false;
    if (!(signature == rhs.signature))
      return false;
    if (!(last_committed_decree_in_app == rhs.last_committed_decree_in_app))
      return false;
    if (!(last_committed_decree_in_prepare_list == rhs.last_committed_decree_in_prepare_list))
      return false;
    if (!(app_specific_learn_request == rhs.app_specific_learn_request))
      return false;
    return true;
  }
  bool operator != (const learn_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const learn_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(learn_request &a, learn_request &b);

inline std::ostream& operator<<(std::ostream& out, const learn_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _learn_response__isset {
  _learn_response__isset() : err(false), config(false), last_committed_decree(false), prepare_start_decree(false), type(true), state(false), address(false), base_local_dir(false) {}
  bool err :1;
  bool config :1;
  bool last_committed_decree :1;
  bool prepare_start_decree :1;
  bool type :1;
  bool state :1;
  bool address :1;
  bool base_local_dir :1;
} _learn_response__isset;

class learn_response {
 public:

  learn_response(const learn_response&);
  learn_response(learn_response&&);
  learn_response& operator=(const learn_response&);
  learn_response& operator=(learn_response&&);
  learn_response() : last_committed_decree(0), prepare_start_decree(0), type((learn_type::type)0), base_local_dir() {
    type = (learn_type::type)0;

  }

  virtual ~learn_response() throw();
   ::dsn::error_code err;
  replica_configuration config;
  int64_t last_committed_decree;
  int64_t prepare_start_decree;
  learn_type::type type;
  learn_state state;
   ::dsn::rpc_address address;
  std::string base_local_dir;

  _learn_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_config(const replica_configuration& val);

  void __set_last_committed_decree(const int64_t val);

  void __set_prepare_start_decree(const int64_t val);

  void __set_type(const learn_type::type val);

  void __set_state(const learn_state& val);

  void __set_address(const  ::dsn::rpc_address& val);

  void __set_base_local_dir(const std::string& val);

  bool operator == (const learn_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(config == rhs.config))
      return false;
    if (!(last_committed_decree == rhs.last_committed_decree))
      return false;
    if (!(prepare_start_decree == rhs.prepare_start_decree))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(state == rhs.state))
      return false;
    if (!(address == rhs.address))
      return false;
    if (!(base_local_dir == rhs.base_local_dir))
      return false;
    return true;
  }
  bool operator != (const learn_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const learn_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(learn_response &a, learn_response &b);

inline std::ostream& operator<<(std::ostream& out, const learn_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _group_check_request__isset {
  _group_check_request__isset() : app(false), node(false), config(false), last_committed_decree(false) {}
  bool app :1;
  bool node :1;
  bool config :1;
  bool last_committed_decree :1;
} _group_check_request__isset;

class group_check_request {
 public:

  group_check_request(const group_check_request&);
  group_check_request(group_check_request&&);
  group_check_request& operator=(const group_check_request&);
  group_check_request& operator=(group_check_request&&);
  group_check_request() : last_committed_decree(0) {
  }

  virtual ~group_check_request() throw();
   ::dsn::app_info app;
   ::dsn::rpc_address node;
  replica_configuration config;
  int64_t last_committed_decree;

  _group_check_request__isset __isset;

  void __set_app(const  ::dsn::app_info& val);

  void __set_node(const  ::dsn::rpc_address& val);

  void __set_config(const replica_configuration& val);

  void __set_last_committed_decree(const int64_t val);

  bool operator == (const group_check_request & rhs) const
  {
    if (!(app == rhs.app))
      return false;
    if (!(node == rhs.node))
      return false;
    if (!(config == rhs.config))
      return false;
    if (!(last_committed_decree == rhs.last_committed_decree))
      return false;
    return true;
  }
  bool operator != (const group_check_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const group_check_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(group_check_request &a, group_check_request &b);

inline std::ostream& operator<<(std::ostream& out, const group_check_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _group_check_response__isset {
  _group_check_response__isset() : pid(false), err(false), last_committed_decree_in_app(false), last_committed_decree_in_prepare_list(false), learner_status_(true), learner_signature(false), node(false) {}
  bool pid :1;
  bool err :1;
  bool last_committed_decree_in_app :1;
  bool last_committed_decree_in_prepare_list :1;
  bool learner_status_ :1;
  bool learner_signature :1;
  bool node :1;
} _group_check_response__isset;

class group_check_response {
 public:

  group_check_response(const group_check_response&);
  group_check_response(group_check_response&&);
  group_check_response& operator=(const group_check_response&);
  group_check_response& operator=(group_check_response&&);
  group_check_response() : last_committed_decree_in_app(0), last_committed_decree_in_prepare_list(0), learner_status_((learner_status::type)0), learner_signature(0) {
    learner_status_ = (learner_status::type)0;

  }

  virtual ~group_check_response() throw();
   ::dsn::gpid pid;
   ::dsn::error_code err;
  int64_t last_committed_decree_in_app;
  int64_t last_committed_decree_in_prepare_list;
  learner_status::type learner_status_;
  int64_t learner_signature;
   ::dsn::rpc_address node;

  _group_check_response__isset __isset;

  void __set_pid(const  ::dsn::gpid& val);

  void __set_err(const  ::dsn::error_code& val);

  void __set_last_committed_decree_in_app(const int64_t val);

  void __set_last_committed_decree_in_prepare_list(const int64_t val);

  void __set_learner_status_(const learner_status::type val);

  void __set_learner_signature(const int64_t val);

  void __set_node(const  ::dsn::rpc_address& val);

  bool operator == (const group_check_response & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(err == rhs.err))
      return false;
    if (!(last_committed_decree_in_app == rhs.last_committed_decree_in_app))
      return false;
    if (!(last_committed_decree_in_prepare_list == rhs.last_committed_decree_in_prepare_list))
      return false;
    if (!(learner_status_ == rhs.learner_status_))
      return false;
    if (!(learner_signature == rhs.learner_signature))
      return false;
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const group_check_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const group_check_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(group_check_response &a, group_check_response &b);

inline std::ostream& operator<<(std::ostream& out, const group_check_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _node_info__isset {
  _node_info__isset() : status(true), address(false) {}
  bool status :1;
  bool address :1;
} _node_info__isset;

class node_info {
 public:

  node_info(const node_info&);
  node_info(node_info&&);
  node_info& operator=(const node_info&);
  node_info& operator=(node_info&&);
  node_info() : status((node_status::type)0) {
    status = (node_status::type)0;

  }

  virtual ~node_info() throw();
  node_status::type status;
   ::dsn::rpc_address address;

  _node_info__isset __isset;

  void __set_status(const node_status::type val);

  void __set_address(const  ::dsn::rpc_address& val);

  bool operator == (const node_info & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(address == rhs.address))
      return false;
    return true;
  }
  bool operator != (const node_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const node_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(node_info &a, node_info &b);

inline std::ostream& operator<<(std::ostream& out, const node_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _meta_response_header__isset {
  _meta_response_header__isset() : err(false), primary_address(false) {}
  bool err :1;
  bool primary_address :1;
} _meta_response_header__isset;

class meta_response_header {
 public:

  meta_response_header(const meta_response_header&);
  meta_response_header(meta_response_header&&);
  meta_response_header& operator=(const meta_response_header&);
  meta_response_header& operator=(meta_response_header&&);
  meta_response_header() {
  }

  virtual ~meta_response_header() throw();
   ::dsn::error_code err;
   ::dsn::rpc_address primary_address;

  _meta_response_header__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_primary_address(const  ::dsn::rpc_address& val);

  bool operator == (const meta_response_header & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(primary_address == rhs.primary_address))
      return false;
    return true;
  }
  bool operator != (const meta_response_header &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const meta_response_header & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(meta_response_header &a, meta_response_header &b);

inline std::ostream& operator<<(std::ostream& out, const meta_response_header& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_update_request__isset {
  _configuration_update_request__isset() : info(false), config(false), type(true), node(false), host_node(false) {}
  bool info :1;
  bool config :1;
  bool type :1;
  bool node :1;
  bool host_node :1;
} _configuration_update_request__isset;

class configuration_update_request {
 public:

  configuration_update_request(const configuration_update_request&);
  configuration_update_request(configuration_update_request&&);
  configuration_update_request& operator=(const configuration_update_request&);
  configuration_update_request& operator=(configuration_update_request&&);
  configuration_update_request() : type((config_type::type)0) {
    type = (config_type::type)0;

  }

  virtual ~configuration_update_request() throw();
   ::dsn::app_info info;
   ::dsn::partition_configuration config;
  config_type::type type;
   ::dsn::rpc_address node;
   ::dsn::rpc_address host_node;

  _configuration_update_request__isset __isset;

  void __set_info(const  ::dsn::app_info& val);

  void __set_config(const  ::dsn::partition_configuration& val);

  void __set_type(const config_type::type val);

  void __set_node(const  ::dsn::rpc_address& val);

  void __set_host_node(const  ::dsn::rpc_address& val);

  bool operator == (const configuration_update_request & rhs) const
  {
    if (!(info == rhs.info))
      return false;
    if (!(config == rhs.config))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(node == rhs.node))
      return false;
    if (!(host_node == rhs.host_node))
      return false;
    return true;
  }
  bool operator != (const configuration_update_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_update_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_update_request &a, configuration_update_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_update_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_update_response__isset {
  _configuration_update_response__isset() : err(false), config(false) {}
  bool err :1;
  bool config :1;
} _configuration_update_response__isset;

class configuration_update_response {
 public:

  configuration_update_response(const configuration_update_response&);
  configuration_update_response(configuration_update_response&&);
  configuration_update_response& operator=(const configuration_update_response&);
  configuration_update_response& operator=(configuration_update_response&&);
  configuration_update_response() {
  }

  virtual ~configuration_update_response() throw();
   ::dsn::error_code err;
   ::dsn::partition_configuration config;

  _configuration_update_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_config(const  ::dsn::partition_configuration& val);

  bool operator == (const configuration_update_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(config == rhs.config))
      return false;
    return true;
  }
  bool operator != (const configuration_update_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_update_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_update_response &a, configuration_update_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_update_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_query_by_node_request__isset {
  _configuration_query_by_node_request__isset() : node(false) {}
  bool node :1;
} _configuration_query_by_node_request__isset;

class configuration_query_by_node_request {
 public:

  configuration_query_by_node_request(const configuration_query_by_node_request&);
  configuration_query_by_node_request(configuration_query_by_node_request&&);
  configuration_query_by_node_request& operator=(const configuration_query_by_node_request&);
  configuration_query_by_node_request& operator=(configuration_query_by_node_request&&);
  configuration_query_by_node_request() {
  }

  virtual ~configuration_query_by_node_request() throw();
   ::dsn::rpc_address node;

  _configuration_query_by_node_request__isset __isset;

  void __set_node(const  ::dsn::rpc_address& val);

  bool operator == (const configuration_query_by_node_request & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const configuration_query_by_node_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_query_by_node_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_query_by_node_request &a, configuration_query_by_node_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_query_by_node_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_query_by_node_response__isset {
  _configuration_query_by_node_response__isset() : err(false), partitions(false) {}
  bool err :1;
  bool partitions :1;
} _configuration_query_by_node_response__isset;

class configuration_query_by_node_response {
 public:

  configuration_query_by_node_response(const configuration_query_by_node_response&);
  configuration_query_by_node_response(configuration_query_by_node_response&&);
  configuration_query_by_node_response& operator=(const configuration_query_by_node_response&);
  configuration_query_by_node_response& operator=(configuration_query_by_node_response&&);
  configuration_query_by_node_response() {
  }

  virtual ~configuration_query_by_node_response() throw();
   ::dsn::error_code err;
  std::vector<configuration_update_request>  partitions;

  _configuration_query_by_node_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_partitions(const std::vector<configuration_update_request> & val);

  bool operator == (const configuration_query_by_node_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const configuration_query_by_node_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_query_by_node_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_query_by_node_response &a, configuration_query_by_node_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_query_by_node_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _create_app_options__isset {
  _create_app_options__isset() : partition_count(false), replica_count(false), success_if_exist(false), app_type(false), is_stateful(false), envs(false) {}
  bool partition_count :1;
  bool replica_count :1;
  bool success_if_exist :1;
  bool app_type :1;
  bool is_stateful :1;
  bool envs :1;
} _create_app_options__isset;

class create_app_options {
 public:

  create_app_options(const create_app_options&);
  create_app_options(create_app_options&&);
  create_app_options& operator=(const create_app_options&);
  create_app_options& operator=(create_app_options&&);
  create_app_options() : partition_count(0), replica_count(0), success_if_exist(0), app_type(), is_stateful(0) {
  }

  virtual ~create_app_options() throw();
  int32_t partition_count;
  int32_t replica_count;
  bool success_if_exist;
  std::string app_type;
  bool is_stateful;
  std::map<std::string, std::string>  envs;

  _create_app_options__isset __isset;

  void __set_partition_count(const int32_t val);

  void __set_replica_count(const int32_t val);

  void __set_success_if_exist(const bool val);

  void __set_app_type(const std::string& val);

  void __set_is_stateful(const bool val);

  void __set_envs(const std::map<std::string, std::string> & val);

  bool operator == (const create_app_options & rhs) const
  {
    if (!(partition_count == rhs.partition_count))
      return false;
    if (!(replica_count == rhs.replica_count))
      return false;
    if (!(success_if_exist == rhs.success_if_exist))
      return false;
    if (!(app_type == rhs.app_type))
      return false;
    if (!(is_stateful == rhs.is_stateful))
      return false;
    if (!(envs == rhs.envs))
      return false;
    return true;
  }
  bool operator != (const create_app_options &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const create_app_options & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(create_app_options &a, create_app_options &b);

inline std::ostream& operator<<(std::ostream& out, const create_app_options& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_create_app_request__isset {
  _configuration_create_app_request__isset() : app_name(false), options(false) {}
  bool app_name :1;
  bool options :1;
} _configuration_create_app_request__isset;

class configuration_create_app_request {
 public:

  configuration_create_app_request(const configuration_create_app_request&);
  configuration_create_app_request(configuration_create_app_request&&);
  configuration_create_app_request& operator=(const configuration_create_app_request&);
  configuration_create_app_request& operator=(configuration_create_app_request&&);
  configuration_create_app_request() : app_name() {
  }

  virtual ~configuration_create_app_request() throw();
  std::string app_name;
  create_app_options options;

  _configuration_create_app_request__isset __isset;

  void __set_app_name(const std::string& val);

  void __set_options(const create_app_options& val);

  bool operator == (const configuration_create_app_request & rhs) const
  {
    if (!(app_name == rhs.app_name))
      return false;
    if (!(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const configuration_create_app_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_create_app_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_create_app_request &a, configuration_create_app_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_create_app_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _drop_app_options__isset {
  _drop_app_options__isset() : success_if_not_exist(false) {}
  bool success_if_not_exist :1;
} _drop_app_options__isset;

class drop_app_options {
 public:

  drop_app_options(const drop_app_options&);
  drop_app_options(drop_app_options&&);
  drop_app_options& operator=(const drop_app_options&);
  drop_app_options& operator=(drop_app_options&&);
  drop_app_options() : success_if_not_exist(0) {
  }

  virtual ~drop_app_options() throw();
  bool success_if_not_exist;

  _drop_app_options__isset __isset;

  void __set_success_if_not_exist(const bool val);

  bool operator == (const drop_app_options & rhs) const
  {
    if (!(success_if_not_exist == rhs.success_if_not_exist))
      return false;
    return true;
  }
  bool operator != (const drop_app_options &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const drop_app_options & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(drop_app_options &a, drop_app_options &b);

inline std::ostream& operator<<(std::ostream& out, const drop_app_options& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_drop_app_request__isset {
  _configuration_drop_app_request__isset() : app_name(false), options(false) {}
  bool app_name :1;
  bool options :1;
} _configuration_drop_app_request__isset;

class configuration_drop_app_request {
 public:

  configuration_drop_app_request(const configuration_drop_app_request&);
  configuration_drop_app_request(configuration_drop_app_request&&);
  configuration_drop_app_request& operator=(const configuration_drop_app_request&);
  configuration_drop_app_request& operator=(configuration_drop_app_request&&);
  configuration_drop_app_request() : app_name() {
  }

  virtual ~configuration_drop_app_request() throw();
  std::string app_name;
  drop_app_options options;

  _configuration_drop_app_request__isset __isset;

  void __set_app_name(const std::string& val);

  void __set_options(const drop_app_options& val);

  bool operator == (const configuration_drop_app_request & rhs) const
  {
    if (!(app_name == rhs.app_name))
      return false;
    if (!(options == rhs.options))
      return false;
    return true;
  }
  bool operator != (const configuration_drop_app_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_drop_app_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_drop_app_request &a, configuration_drop_app_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_drop_app_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_list_apps_request__isset {
  _configuration_list_apps_request__isset() : status(true) {}
  bool status :1;
} _configuration_list_apps_request__isset;

class configuration_list_apps_request {
 public:

  configuration_list_apps_request(const configuration_list_apps_request&);
  configuration_list_apps_request(configuration_list_apps_request&&);
  configuration_list_apps_request& operator=(const configuration_list_apps_request&);
  configuration_list_apps_request& operator=(configuration_list_apps_request&&);
  configuration_list_apps_request() : status(( ::dsn::app_status::type)0) {
    status = ( ::dsn::app_status::type)0;

  }

  virtual ~configuration_list_apps_request() throw();
   ::dsn::app_status::type status;

  _configuration_list_apps_request__isset __isset;

  void __set_status(const  ::dsn::app_status::type val);

  bool operator == (const configuration_list_apps_request & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const configuration_list_apps_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_list_apps_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_list_apps_request &a, configuration_list_apps_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_list_apps_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_list_nodes_request__isset {
  _configuration_list_nodes_request__isset() : status(true) {}
  bool status :1;
} _configuration_list_nodes_request__isset;

class configuration_list_nodes_request {
 public:

  configuration_list_nodes_request(const configuration_list_nodes_request&);
  configuration_list_nodes_request(configuration_list_nodes_request&&);
  configuration_list_nodes_request& operator=(const configuration_list_nodes_request&);
  configuration_list_nodes_request& operator=(configuration_list_nodes_request&&);
  configuration_list_nodes_request() : status((node_status::type)0) {
    status = (node_status::type)0;

  }

  virtual ~configuration_list_nodes_request() throw();
  node_status::type status;

  _configuration_list_nodes_request__isset __isset;

  void __set_status(const node_status::type val);

  bool operator == (const configuration_list_nodes_request & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const configuration_list_nodes_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_list_nodes_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_list_nodes_request &a, configuration_list_nodes_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_list_nodes_request& obj)
{
  obj.printTo(out);
  return out;
}


class configuration_cluster_info_request {
 public:

  configuration_cluster_info_request(const configuration_cluster_info_request&);
  configuration_cluster_info_request(configuration_cluster_info_request&&);
  configuration_cluster_info_request& operator=(const configuration_cluster_info_request&);
  configuration_cluster_info_request& operator=(configuration_cluster_info_request&&);
  configuration_cluster_info_request() {
  }

  virtual ~configuration_cluster_info_request() throw();

  bool operator == (const configuration_cluster_info_request & /* rhs */) const
  {
    return true;
  }
  bool operator != (const configuration_cluster_info_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_cluster_info_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_cluster_info_request &a, configuration_cluster_info_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_cluster_info_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_create_app_response__isset {
  _configuration_create_app_response__isset() : err(false), appid(false) {}
  bool err :1;
  bool appid :1;
} _configuration_create_app_response__isset;

class configuration_create_app_response {
 public:

  configuration_create_app_response(const configuration_create_app_response&);
  configuration_create_app_response(configuration_create_app_response&&);
  configuration_create_app_response& operator=(const configuration_create_app_response&);
  configuration_create_app_response& operator=(configuration_create_app_response&&);
  configuration_create_app_response() : appid(0) {
  }

  virtual ~configuration_create_app_response() throw();
   ::dsn::error_code err;
  int32_t appid;

  _configuration_create_app_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_appid(const int32_t val);

  bool operator == (const configuration_create_app_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(appid == rhs.appid))
      return false;
    return true;
  }
  bool operator != (const configuration_create_app_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_create_app_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_create_app_response &a, configuration_create_app_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_create_app_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_meta_control_request__isset {
  _configuration_meta_control_request__isset() : ctrl_flags(false), ctrl_type(false) {}
  bool ctrl_flags :1;
  bool ctrl_type :1;
} _configuration_meta_control_request__isset;

class configuration_meta_control_request {
 public:

  configuration_meta_control_request(const configuration_meta_control_request&);
  configuration_meta_control_request(configuration_meta_control_request&&);
  configuration_meta_control_request& operator=(const configuration_meta_control_request&);
  configuration_meta_control_request& operator=(configuration_meta_control_request&&);
  configuration_meta_control_request() : ctrl_flags(0), ctrl_type((meta_ctrl_type::type)0) {
  }

  virtual ~configuration_meta_control_request() throw();
  int64_t ctrl_flags;
  meta_ctrl_type::type ctrl_type;

  _configuration_meta_control_request__isset __isset;

  void __set_ctrl_flags(const int64_t val);

  void __set_ctrl_type(const meta_ctrl_type::type val);

  bool operator == (const configuration_meta_control_request & rhs) const
  {
    if (!(ctrl_flags == rhs.ctrl_flags))
      return false;
    if (!(ctrl_type == rhs.ctrl_type))
      return false;
    return true;
  }
  bool operator != (const configuration_meta_control_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_meta_control_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_meta_control_request &a, configuration_meta_control_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_meta_control_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_meta_control_response__isset {
  _configuration_meta_control_response__isset() : err(false) {}
  bool err :1;
} _configuration_meta_control_response__isset;

class configuration_meta_control_response {
 public:

  configuration_meta_control_response(const configuration_meta_control_response&);
  configuration_meta_control_response(configuration_meta_control_response&&);
  configuration_meta_control_response& operator=(const configuration_meta_control_response&);
  configuration_meta_control_response& operator=(configuration_meta_control_response&&);
  configuration_meta_control_response() {
  }

  virtual ~configuration_meta_control_response() throw();
   ::dsn::error_code err;

  _configuration_meta_control_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  bool operator == (const configuration_meta_control_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const configuration_meta_control_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_meta_control_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_meta_control_response &a, configuration_meta_control_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_meta_control_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_proposal_action__isset {
  _configuration_proposal_action__isset() : target(false), node(false), type(false) {}
  bool target :1;
  bool node :1;
  bool type :1;
} _configuration_proposal_action__isset;

class configuration_proposal_action {
 public:
  configuration_proposal_action(::dsn::rpc_address t, ::dsn::rpc_address n, config_type::type tp): target(t), node(n), type(tp) {}

  configuration_proposal_action(const configuration_proposal_action&);
  configuration_proposal_action(configuration_proposal_action&&);
  configuration_proposal_action& operator=(const configuration_proposal_action&);
  configuration_proposal_action& operator=(configuration_proposal_action&&);
  configuration_proposal_action() : type((config_type::type)0) {
  }

  virtual ~configuration_proposal_action() throw();
   ::dsn::rpc_address target;
   ::dsn::rpc_address node;
  config_type::type type;

  _configuration_proposal_action__isset __isset;

  void __set_target(const  ::dsn::rpc_address& val);

  void __set_node(const  ::dsn::rpc_address& val);

  void __set_type(const config_type::type val);

  bool operator == (const configuration_proposal_action & rhs) const
  {
    if (!(target == rhs.target))
      return false;
    if (!(node == rhs.node))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const configuration_proposal_action &rhs) const {
    return !(*this == rhs);
  }


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_proposal_action &a, configuration_proposal_action &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_proposal_action& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_balancer_request__isset {
  _configuration_balancer_request__isset() : gpid(false), action_list(false), force(true) {}
  bool gpid :1;
  bool action_list :1;
  bool force :1;
} _configuration_balancer_request__isset;

class configuration_balancer_request {
 public:

  configuration_balancer_request(const configuration_balancer_request&);
  configuration_balancer_request(configuration_balancer_request&&);
  configuration_balancer_request& operator=(const configuration_balancer_request&);
  configuration_balancer_request& operator=(configuration_balancer_request&&);
  configuration_balancer_request() : force(false) {
  }

  virtual ~configuration_balancer_request() throw();
   ::dsn::gpid gpid;
  std::vector<configuration_proposal_action>  action_list;
  bool force;

  _configuration_balancer_request__isset __isset;

  void __set_gpid(const  ::dsn::gpid& val);

  void __set_action_list(const std::vector<configuration_proposal_action> & val);

  void __set_force(const bool val);

  bool operator == (const configuration_balancer_request & rhs) const
  {
    if (!(gpid == rhs.gpid))
      return false;
    if (!(action_list == rhs.action_list))
      return false;
    if (__isset.force != rhs.__isset.force)
      return false;
    else if (__isset.force && !(force == rhs.force))
      return false;
    return true;
  }
  bool operator != (const configuration_balancer_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_balancer_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_balancer_request &a, configuration_balancer_request &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_balancer_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_balancer_response__isset {
  _configuration_balancer_response__isset() : err(false) {}
  bool err :1;
} _configuration_balancer_response__isset;

class configuration_balancer_response {
 public:

  configuration_balancer_response(const configuration_balancer_response&);
  configuration_balancer_response(configuration_balancer_response&&);
  configuration_balancer_response& operator=(const configuration_balancer_response&);
  configuration_balancer_response& operator=(configuration_balancer_response&&);
  configuration_balancer_response() {
  }

  virtual ~configuration_balancer_response() throw();
   ::dsn::error_code err;

  _configuration_balancer_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  bool operator == (const configuration_balancer_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const configuration_balancer_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_balancer_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_balancer_response &a, configuration_balancer_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_balancer_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_drop_app_response__isset {
  _configuration_drop_app_response__isset() : err(false) {}
  bool err :1;
} _configuration_drop_app_response__isset;

class configuration_drop_app_response {
 public:

  configuration_drop_app_response(const configuration_drop_app_response&);
  configuration_drop_app_response(configuration_drop_app_response&&);
  configuration_drop_app_response& operator=(const configuration_drop_app_response&);
  configuration_drop_app_response& operator=(configuration_drop_app_response&&);
  configuration_drop_app_response() {
  }

  virtual ~configuration_drop_app_response() throw();
   ::dsn::error_code err;

  _configuration_drop_app_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  bool operator == (const configuration_drop_app_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    return true;
  }
  bool operator != (const configuration_drop_app_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_drop_app_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_drop_app_response &a, configuration_drop_app_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_drop_app_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_list_apps_response__isset {
  _configuration_list_apps_response__isset() : err(false), infos(false) {}
  bool err :1;
  bool infos :1;
} _configuration_list_apps_response__isset;

class configuration_list_apps_response {
 public:

  configuration_list_apps_response(const configuration_list_apps_response&);
  configuration_list_apps_response(configuration_list_apps_response&&);
  configuration_list_apps_response& operator=(const configuration_list_apps_response&);
  configuration_list_apps_response& operator=(configuration_list_apps_response&&);
  configuration_list_apps_response() {
  }

  virtual ~configuration_list_apps_response() throw();
   ::dsn::error_code err;
  std::vector< ::dsn::app_info>  infos;

  _configuration_list_apps_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_infos(const std::vector< ::dsn::app_info> & val);

  bool operator == (const configuration_list_apps_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(infos == rhs.infos))
      return false;
    return true;
  }
  bool operator != (const configuration_list_apps_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_list_apps_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_list_apps_response &a, configuration_list_apps_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_list_apps_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_list_nodes_response__isset {
  _configuration_list_nodes_response__isset() : err(false), infos(false) {}
  bool err :1;
  bool infos :1;
} _configuration_list_nodes_response__isset;

class configuration_list_nodes_response {
 public:

  configuration_list_nodes_response(const configuration_list_nodes_response&);
  configuration_list_nodes_response(configuration_list_nodes_response&&);
  configuration_list_nodes_response& operator=(const configuration_list_nodes_response&);
  configuration_list_nodes_response& operator=(configuration_list_nodes_response&&);
  configuration_list_nodes_response() {
  }

  virtual ~configuration_list_nodes_response() throw();
   ::dsn::error_code err;
  std::vector<node_info>  infos;

  _configuration_list_nodes_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_infos(const std::vector<node_info> & val);

  bool operator == (const configuration_list_nodes_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(infos == rhs.infos))
      return false;
    return true;
  }
  bool operator != (const configuration_list_nodes_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_list_nodes_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_list_nodes_response &a, configuration_list_nodes_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_list_nodes_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _configuration_cluster_info_response__isset {
  _configuration_cluster_info_response__isset() : err(false), keys(false), values(false) {}
  bool err :1;
  bool keys :1;
  bool values :1;
} _configuration_cluster_info_response__isset;

class configuration_cluster_info_response {
 public:

  configuration_cluster_info_response(const configuration_cluster_info_response&);
  configuration_cluster_info_response(configuration_cluster_info_response&&);
  configuration_cluster_info_response& operator=(const configuration_cluster_info_response&);
  configuration_cluster_info_response& operator=(configuration_cluster_info_response&&);
  configuration_cluster_info_response() {
  }

  virtual ~configuration_cluster_info_response() throw();
   ::dsn::error_code err;
  std::vector<std::string>  keys;
  std::vector<std::string>  values;

  _configuration_cluster_info_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_keys(const std::vector<std::string> & val);

  void __set_values(const std::vector<std::string> & val);

  bool operator == (const configuration_cluster_info_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(keys == rhs.keys))
      return false;
    if (!(values == rhs.values))
      return false;
    return true;
  }
  bool operator != (const configuration_cluster_info_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const configuration_cluster_info_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(configuration_cluster_info_response &a, configuration_cluster_info_response &b);

inline std::ostream& operator<<(std::ostream& out, const configuration_cluster_info_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _query_replica_decree_request__isset {
  _query_replica_decree_request__isset() : pid(false), node(false) {}
  bool pid :1;
  bool node :1;
} _query_replica_decree_request__isset;

class query_replica_decree_request {
 public:

  query_replica_decree_request(const query_replica_decree_request&);
  query_replica_decree_request(query_replica_decree_request&&);
  query_replica_decree_request& operator=(const query_replica_decree_request&);
  query_replica_decree_request& operator=(query_replica_decree_request&&);
  query_replica_decree_request() {
  }

  virtual ~query_replica_decree_request() throw();
   ::dsn::gpid pid;
   ::dsn::rpc_address node;

  _query_replica_decree_request__isset __isset;

  void __set_pid(const  ::dsn::gpid& val);

  void __set_node(const  ::dsn::rpc_address& val);

  bool operator == (const query_replica_decree_request & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const query_replica_decree_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const query_replica_decree_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(query_replica_decree_request &a, query_replica_decree_request &b);

inline std::ostream& operator<<(std::ostream& out, const query_replica_decree_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _query_replica_decree_response__isset {
  _query_replica_decree_response__isset() : err(false), last_decree(false) {}
  bool err :1;
  bool last_decree :1;
} _query_replica_decree_response__isset;

class query_replica_decree_response {
 public:

  query_replica_decree_response(const query_replica_decree_response&);
  query_replica_decree_response(query_replica_decree_response&&);
  query_replica_decree_response& operator=(const query_replica_decree_response&);
  query_replica_decree_response& operator=(query_replica_decree_response&&);
  query_replica_decree_response() : last_decree(0) {
  }

  virtual ~query_replica_decree_response() throw();
   ::dsn::error_code err;
  int64_t last_decree;

  _query_replica_decree_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_last_decree(const int64_t val);

  bool operator == (const query_replica_decree_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(last_decree == rhs.last_decree))
      return false;
    return true;
  }
  bool operator != (const query_replica_decree_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const query_replica_decree_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(query_replica_decree_response &a, query_replica_decree_response &b);

inline std::ostream& operator<<(std::ostream& out, const query_replica_decree_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _replica_info__isset {
  _replica_info__isset() : pid(false), ballot(false), status(false), last_committed_decree(false), last_prepared_decree(false), last_durable_decree(false) {}
  bool pid :1;
  bool ballot :1;
  bool status :1;
  bool last_committed_decree :1;
  bool last_prepared_decree :1;
  bool last_durable_decree :1;
} _replica_info__isset;

class replica_info {
 public:

  replica_info(const replica_info&);
  replica_info(replica_info&&);
  replica_info& operator=(const replica_info&);
  replica_info& operator=(replica_info&&);
  replica_info() : ballot(0), status((partition_status::type)0), last_committed_decree(0), last_prepared_decree(0), last_durable_decree(0) {
  }

  virtual ~replica_info() throw();
   ::dsn::gpid pid;
  int64_t ballot;
  partition_status::type status;
  int64_t last_committed_decree;
  int64_t last_prepared_decree;
  int64_t last_durable_decree;

  _replica_info__isset __isset;

  void __set_pid(const  ::dsn::gpid& val);

  void __set_ballot(const int64_t val);

  void __set_status(const partition_status::type val);

  void __set_last_committed_decree(const int64_t val);

  void __set_last_prepared_decree(const int64_t val);

  void __set_last_durable_decree(const int64_t val);

  bool operator == (const replica_info & rhs) const
  {
    if (!(pid == rhs.pid))
      return false;
    if (!(ballot == rhs.ballot))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(last_committed_decree == rhs.last_committed_decree))
      return false;
    if (!(last_prepared_decree == rhs.last_prepared_decree))
      return false;
    if (!(last_durable_decree == rhs.last_durable_decree))
      return false;
    return true;
  }
  bool operator != (const replica_info &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const replica_info & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(replica_info &a, replica_info &b);

inline std::ostream& operator<<(std::ostream& out, const replica_info& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _query_replica_info_request__isset {
  _query_replica_info_request__isset() : node(false) {}
  bool node :1;
} _query_replica_info_request__isset;

class query_replica_info_request {
 public:

  query_replica_info_request(const query_replica_info_request&);
  query_replica_info_request(query_replica_info_request&&);
  query_replica_info_request& operator=(const query_replica_info_request&);
  query_replica_info_request& operator=(query_replica_info_request&&);
  query_replica_info_request() {
  }

  virtual ~query_replica_info_request() throw();
   ::dsn::rpc_address node;

  _query_replica_info_request__isset __isset;

  void __set_node(const  ::dsn::rpc_address& val);

  bool operator == (const query_replica_info_request & rhs) const
  {
    if (!(node == rhs.node))
      return false;
    return true;
  }
  bool operator != (const query_replica_info_request &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const query_replica_info_request & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(query_replica_info_request &a, query_replica_info_request &b);

inline std::ostream& operator<<(std::ostream& out, const query_replica_info_request& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _query_replica_info_response__isset {
  _query_replica_info_response__isset() : err(false), replicas(false) {}
  bool err :1;
  bool replicas :1;
} _query_replica_info_response__isset;

class query_replica_info_response {
 public:

  query_replica_info_response(const query_replica_info_response&);
  query_replica_info_response(query_replica_info_response&&);
  query_replica_info_response& operator=(const query_replica_info_response&);
  query_replica_info_response& operator=(query_replica_info_response&&);
  query_replica_info_response() {
  }

  virtual ~query_replica_info_response() throw();
   ::dsn::error_code err;
  std::vector<replica_info>  replicas;

  _query_replica_info_response__isset __isset;

  void __set_err(const  ::dsn::error_code& val);

  void __set_replicas(const std::vector<replica_info> & val);

  bool operator == (const query_replica_info_response & rhs) const
  {
    if (!(err == rhs.err))
      return false;
    if (!(replicas == rhs.replicas))
      return false;
    return true;
  }
  bool operator != (const query_replica_info_response &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const query_replica_info_response & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(query_replica_info_response &a, query_replica_info_response &b);

inline std::ostream& operator<<(std::ostream& out, const query_replica_info_response& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _node_state__isset {
  _node_state__isset() : is_alive(false), address(false), primaries(false), partitions(false) {}
  bool is_alive :1;
  bool address :1;
  bool primaries :1;
  bool partitions :1;
} _node_state__isset;

class node_state {
 public:

  node_state(const node_state&);
  node_state(node_state&&);
  node_state& operator=(const node_state&);
  node_state& operator=(node_state&&);
  node_state() : is_alive(0) {
  }

  virtual ~node_state() throw();
  bool is_alive;
   ::dsn::rpc_address address;
  std::set< ::dsn::gpid>  primaries;
  std::set< ::dsn::gpid>  partitions;

  _node_state__isset __isset;

  void __set_is_alive(const bool val);

  void __set_address(const  ::dsn::rpc_address& val);

  void __set_primaries(const std::set< ::dsn::gpid> & val);

  void __set_partitions(const std::set< ::dsn::gpid> & val);

  bool operator == (const node_state & rhs) const
  {
    if (!(is_alive == rhs.is_alive))
      return false;
    if (!(address == rhs.address))
      return false;
    if (!(primaries == rhs.primaries))
      return false;
    if (!(partitions == rhs.partitions))
      return false;
    return true;
  }
  bool operator != (const node_state &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const node_state & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(node_state &a, node_state &b);

inline std::ostream& operator<<(std::ostream& out, const node_state& obj)
{
  obj.printTo(out);
  return out;
}

}} // namespace

#endif
